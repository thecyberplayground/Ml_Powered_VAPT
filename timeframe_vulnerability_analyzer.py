#!/usr/bin/env python3
"""
FinGuardAI - Timeframe Vulnerability Analyzer

This tool provides precise timeframe vulnerability predictions:
- 1-day (immediate action required)
- 1-week (urgent action required)
- 10-day (important action required)

Based on real NVD API data with accurate EOL dates for technologies.
"""

import os
import sys
import json
import time
import logging
import argparse
import datetime
from typing import Dict, List, Any, Optional

# Import our NVD client implementation
from ml.remediation.nvd_client import NVDClient
from ml.remediation.nvd_vulnerability_predictor import VulnerabilityPredictor

# Configure logging to file only
log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logs")
os.makedirs(log_dir, exist_ok=True)
log_file = os.path.join(log_dir, "timeframe_analyzer.log")

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
    ]
)
logger = logging.getLogger("finguardai.analyzer")

# Known technology mappings for specific targets
TECHNOLOGY_MAPPINGS = {
    "stampduty.gov.ng": {
        "apache": "2.4.51",
        "php": "7.4.21",
        "mysql": "5.7.36",
        "openssh": "8.2p1"
    },
    "portal.lcu.edu.ng": {
        "nginx": "1.20.1",
        "php": "8.0.10"
    },
    "tryhackme.com": {
        "nginx": "1.18.0",
        "php": "7.4.3"
    }
}

def print_header():
    """Print tool header"""
    print("\n" + "=" * 80)
    print(" FinGuardAI - Timeframe Vulnerability Analyzer ")
    print("=" * 80)
    print(f"Analysis Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("-" * 80)

def print_report(target: str, predictions: Dict[str, Any]) -> None:
    """
    Print formatted vulnerability report with precise timeframes
    
    Args:
        target: Target name
        predictions: Vulnerability predictions
    """
    print("\n" + "=" * 80)
    print(f" VULNERABILITY PREDICTION REPORT - {target} ")
    print("=" * 80)
    
    summary = predictions.get("summary", {})
    
    # Print summary with clear counts
    print("\nVULNERABILITY SUMMARY:")
    print(f"  • Critical (1-Day):   {summary.get('1_day_count', 0)}")
    print(f"  • Urgent (1-Week):    {summary.get('1_week_count', 0)}")
    print(f"  • Important (10-Day): {summary.get('10_days_count', 0)}")
    print(f"  • Total Technologies: {summary.get('tech_specific_count', 0)}")
    
    # Print each timeframe section
    timeframes = [
        {
            "key": "1_day", 
            "title": "CRITICAL - IMMEDIATE ACTION REQUIRED (1-DAY)",
            "desc": "The following vulnerabilities require action within 24 hours:"
        },
        {
            "key": "1_week",
            "title": "URGENT - ACTION REQUIRED WITHIN ONE WEEK",
            "desc": "The following vulnerabilities require action within 7 days:"
        }, 
        {
            "key": "10_days",
            "title": "IMPORTANT - ACTION REQUIRED WITHIN 10 DAYS",
            "desc": "The following vulnerabilities require action within 10 days:"
        }
    ]
    
    for tf in timeframes:
        vulns = predictions.get(tf["key"], [])
        if not vulns:
            continue
            
        print(f"\n[{tf['title']}]")
        print(f"{tf['desc']}")
        
        for i, vuln in enumerate(vulns, 1):
            print(f"\n  {i}. {vuln['technology']} {vuln['current_version']} → {vuln['recommended_version']}")
            print(f"     Confidence: {vuln['prediction_confidence']:.2f}")
            print(f"     Vulnerability Types: {', '.join(vuln['vulnerability_types'])}")
            print(f"     Recommendation: {vuln['detailed_recommendation']}")
            
            if vuln.get('affected_cves'):
                print(f"     Related CVEs: {', '.join(vuln['affected_cves'][:5])}")
    
    # Print technology upgrade summary
    if predictions.get("tech_specific"):
        print("\nTECHNOLOGY UPGRADE SUMMARY:")
        
        for vuln in predictions.get("tech_specific", []):
            print(f"  • {vuln['technology']} {vuln['current_version']} → {vuln['recommended_version']}")
    
    print("\n" + "-" * 80)

def analyze_target(target: str, api_key: Optional[str] = None) -> Dict[str, Any]:
    """
    Analyze target for vulnerabilities with precise timeframes
    
    Args:
        target: Target name/identifier
        api_key: Optional NVD API key
        
    Returns:
        Dictionary with vulnerability predictions by timeframe
    """
    logger.info(f"Analyzing target: {target}")
    
    # Create predictor
    predictor = VulnerabilityPredictor(api_key=api_key)
    
    # Create scan results structure
    scan_results = {"host": target}
    
    # Add technology information if available
    if target in TECHNOLOGY_MAPPINGS:
        tech_mapping = TECHNOLOGY_MAPPINGS[target]
        scan_results["additional_info"] = {"technologies": tech_mapping}
        
        print(f"Using technology mapping for {target}:")
        for tech, version in tech_mapping.items():
            print(f"  • {tech}: {version}")
    else:
        print(f"No technology mapping found for {target}. Using fallback detection.")
    
    # Generate predictions
    print("\nGenerating timeframe vulnerability predictions...")
    predictions = predictor.predict_vulnerabilities(scan_results)
    
    return predictions

def main() -> int:
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="FinGuardAI Timeframe Vulnerability Analyzer"
    )
    parser.add_argument("--target", "-t", help="Target to analyze")
    parser.add_argument("--api-key", "-k", help="NVD API key")
    parser.add_argument("--json", "-j", action="store_true", help="Output in JSON format")
    parser.add_argument("--all", "-a", action="store_true", help="Analyze all known targets")
    args = parser.parse_args()
    
    # Print header
    print_header()
    
    # Get NVD API key
    api_key = args.api_key or os.environ.get("NVD_API_KEY") or "7a30b327-dc77-4262-acc6-399171f7dacb"
    
    # Determine targets to analyze
    targets = []
    
    if args.target:
        # Single target specified
        targets.append(args.target)
    elif args.all:
        # Analyze all known targets
        targets = list(TECHNOLOGY_MAPPINGS.keys())
    else:
        # Default to stampduty.gov.ng
        targets = ["stampduty.gov.ng"]
    
    if not args.json:
        print(f"\nAnalyzing {len(targets)} target(s) for vulnerabilities with precise timeframes")
    
    results = {}
    
    for target in targets:
        start_time = time.time()
        
        try:
            if not args.json:
                print(f"\n{'-' * 80}\nAnalyzing: {target}")
            
            # Analyze target
            predictions = analyze_target(target, api_key)
            
            # Store results
            results[target] = predictions
            
            # Print report
            if not args.json:
                print_report(target, predictions)
                
            end_time = time.time()
            if not args.json:
                print(f"Analysis completed in {end_time - start_time:.2f} seconds")
            
        except Exception as e:
            logger.error(f"Error analyzing {target}: {e}")
            if not args.json:
                print(f"Error analyzing {target}: {e}")
            results[target] = {"error": str(e)}
        
        # Add delay between targets to avoid rate limiting
        if targets.index(target) < len(targets) - 1:
            time.sleep(1)
    
    # Output JSON if requested
    if args.json:
        print(json.dumps({
            "timestamp": datetime.datetime.now().isoformat(),
            "results": results
        }, indent=2))
    else:
        print("\n" + "=" * 80)
        print(" Analysis Summary ")
        print("=" * 80)
        
        print("\nVulnerability Predictions by Timeframe:")
        
        for target, predictions in results.items():
            summary = predictions.get("summary", {})
            print(f"- {target}:")
            print(f"  • Critical (1-Day): {summary.get('1_day_count', 0)}")
            print(f"  • Urgent (1-Week): {summary.get('1_week_count', 0)}")
            print(f"  • Important (10-Day): {summary.get('10_days_count', 0)}")
        
        print(f"\nAnalysis complete. Log file: {log_file}")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
